# AI Development Agent Guidelines

## Project Overview
**Project:** ai-planner-assistant
**** This repository, `ai-planner-assistant`, serves as a robust full-stack web application starter template, perfectly suited for building your intended **AI Virtual Assistant**. It leverages modern web development technologies to provide a solid foundation for your application, which will manage schedules, tasks, and expenses through an AI-powered chat interface.

### 1. What this codebase does (purpose and functionality)

The core purpose of this codebase is to provide a comprehensive, pre-configured boilerplate for a Next.js 15 application. It provides the essential building blocks for your AI assistant:
*   **User Authentication:** A complete sign-up and sign-in flow powered by "Better Auth." This is crucial for creating a personalized experience where each user's calendar, tasks, and expenses are private and secure.
*   **Dashboard Functionality:** A protected dashboard area that serves as the perfect canvas for your visual components like a **calendar, to-do list, and expense tracker**. The existing static data components can be easily adapted to display dynamic data from your database.
*   **Modern UI:** A sleek and consistent user interface built with Tailwind CSS v4 and `shadcn/ui` components. These pre-built components will accelerate the development of both your **AI chat interface** and your data visualization dashboard.
*   **Database Integration (Configured for PostgreSQL):** The project is already set up for PostgreSQL interaction using Drizzle ORM. This is the exact stack you need to store user-specific data like events, tasks, and financial transactions generated by the AI.
*   **Developer Experience:** Docker support simplifies the local development setup, ensuring you and a potential team can get the application and its PostgreSQL database running with a single command.

Essentially, it's an opinionated starter kit that jumpstarts your project by handling the foundational work, allowing you to focus on the unique features of your AI assistant.

### 2. Key Architecture and Technology Choices

The architecture is a modern full-stack approach centered around the **Next.js App Router**, which is highly advantageous for your project:

*   **Frontend Framework:** **Next.js 15** with the **App Router** is ideal. You can use Server Components for efficiently rendering the dashboard (calendar, tasks) and Client Components for the highly interactive **AI chat page**.
*   **Language:** **TypeScript** provides strong typing, which will be invaluable for defining clear data structures for your `events`, `tasks`, and `expenses`, and for safely handling the structured data you'll receive from the OpenAI API.
*   **Styling:** **Tailwind CSS v4** and **shadcn/ui** give you a rich library of components (`Input`, `Button`, `Card`) to quickly build a polished chat interface and a visually appealing dashboard.
*   **Authentication:** **Better Auth** provides the necessary user session management to ensure that API requests to create tasks or view calendars are securely associated with the logged-in user.
*   **Database ORM:** **Drizzle ORM** with **PostgreSQL** is the perfect combination for your needs, offering a type-safe way to define your database schema and interact with your data. You'll define tables for users, events, tasks, etc., and Drizzle will ensure your code communicates with them correctly.
*   **Containerization:** **Docker** for local development means you don't have to manually install and configure PostgreSQL, streamlining your setup process.

### 3. Main Components and how they interact

The codebase is organized logically, and you will extend it as follows to build your assistant:

*   **`app/`**: The core of your application.
    *   `app/(auth)/...`: The existing sign-in/sign-up pages will onboard users to their personal planning space.
    *   `app/dashboard/page.tsx`: This will be the main view for your **calendar, to-do list, and expense tracker**. You will replace the static data with dynamic data fetched for the logged-in user.
    *   **`app/chat/page.tsx` (New):** You will create this new route to house the primary **AI chat interface** where users interact with the GPT-4o assistant.
    *   **`app/api/chat/route.ts` (New):** This new API route will be the backend for your chat. It will receive user messages, securely call the OpenAI API with GPT-4o, interpret the AI's response (e.g., "create a task"), and use Drizzle to perform the corresponding database operation.
*   **`components/`**: Reusable React components.
    *   `components/ui/`: You will heavily use these `shadcn/ui` components to build your chat bubbles, input fields, calendar views, and task lists.
    *   `components/data-table.tsx`: This is a perfect starting point for building your **to-do list or expense tracker**.
    *   `components/chart-area-interactive.tsx`: This can be adapted to create visualizations for your **expense tracking feature**.
*   **`db/`**: Your application's data layer.
    *   `db/schema.ts`: This is a critical file you will modify. You will extend it to define the schemas for your application's data, such as `tasks`, `calendarEvents`, and `expenses`, linking them to the existing `users` table.
*   **`lib/`**: Utility functions and business logic.
    *   `lib/auth.ts`: The existing server-side auth utilities will be used in your new API routes to ensure only authenticated users can interact with the AI and their data.
    *   **`lib/openai.ts` (New):** It would be a good practice to create a new file here to encapsulate the logic for interacting with the OpenAI API, including client initialization and prompt engineering.

**Interactions for Your Use Case:**
1.  A user types a command ("Remind me to call the doctor tomorrow at 2 PM") into the **chat interface** (`app/chat/page.tsx`).
2.  The chat interface sends this message to your new API route (`app/api/chat/route.ts`).
3.  The API route, after verifying the user's session, sends a carefully crafted prompt to the **OpenAI GPT-4o API** via `lib/openai.ts`.
4.  GPT-4o processes the natural language and returns structured data (e.g., JSON for a new event).
5.  Your API route parses this data and uses **Drizzle ORM** to insert a new record into the `calendarEvents` table in your PostgreSQL database.
6.  When the user navigates to the **dashboard** (`app/dashboard/page.tsx`), the page fetches all events for that user from the database and displays them on the calendar.

### 4. Notable Patterns, Configurations, or Design Decisions

*   **Type Safety from End-to-End:** The combination of TypeScript and Drizzle is a major strength. It allows you to define a type for a `Task` in your database schema and ensure that the data parsed from the OpenAI API conforms to that type before it's saved, preventing data corruption.
*   **Server-Side Logic Colocation:** Using Next.js API Routes or Server Actions allows you to keep your backend logic (like calling the OpenAI API and writing to the database) within the same project, simplifying development.
*   **Component-Based UI:** The use of `shadcn/ui` provides a powerful, composable system to build a sophisticated and consistent UI for your dashboard widgets and chat components without writing CSS from scratch.
*   **Docker for Dev Environment:** This decision is excellent for your project, as it ensures the PostgreSQL database is set up correctly and consistently every time you start working.

### 5. Overall Code Structure and Organization

The project's standard Next.js structure is well-suited for your goals. You will primarily be:
*   Adding new routes in `app/` (e.g., `chat`).
*   Adding new API endpoints in `app/api/` (e.g., `chat`).
*   Creating new UI components in `components/` (e.g., `calendar.tsx`, `chat-message.tsx`).
*   Defining your application's data models in `db/schema.ts`.
*   Adding business logic for AI interaction in `lib/`.

This organization keeps your concerns separated and makes the project easy to navigate as it grows.

### 6. Code Quality Observations and Recommendations

**Observations:**

*   The starter kit's foundation is strong, modern, and type-safe, which is an excellent starting point for a data-intensive application like an AI planner.
*   The choice of `shadcn/ui` provides high-quality, accessible UI primitives, saving significant development time.

**Recommendations Tailored to Your Project:**

*   **Implement a Testing Suite:** Write tests specifically for your AI interaction logic. For example, create unit tests that simulate OpenAI API responses and verify that your code correctly parses them and prepares the right data for the database.
*   **Robust Error Handling:** Implement comprehensive error handling for your `/api/chat` route. You need to gracefully handle scenarios where the OpenAI API is down, returns an unexpected format, or the database write fails, and provide clear feedback to the user in the chat interface.
*   **Prompt Engineering and Management:** Your AI's effectiveness will depend heavily on your prompts. Store your system prompts and function-calling schemas in a structured way (e.g., in `lib/prompts.ts`) rather than hardcoding them in the API route.
*   **Environment Variables:** Securely manage your `OPENAI_API_KEY` and other secrets using environment variables. The existing `.env.example` is a good place to document this.

### 7. Potential Areas for Improvement or Refactoring (Your Roadmap)

*   **Implement Full Database Schema:** Your first and most critical task is to define the database schema in `db/schema.ts`. You'll need tables for `tasks`, `events`, `expenses`, and potentially `reminders`, all linked to the `userId`.
*   **Build the AI Chat Backend:** Create the `/api/chat/route.ts`. This will be the brain of your assistant. Focus on:
    *   Receiving the user's message.
    *   Constructing a detailed prompt for GPT-4o, possibly using function calling to get structured output.
    *   Parsing the AI's response.
    *   Using a `switch` statement or other logic to determine the user's intent (e.g., create task, add event).
    *   Calling the appropriate Drizzle function to update the database.
*   **Develop the Chat and Dashboard UIs:**
    *   Build the `app/chat/page.tsx` with a message list and input form.
    *   Transform `app/dashboard/page.tsx` from a static page into a dynamic one that fetches and displays the user's data. You may want to use a library like `react-big-calendar` for the calendar view.
*   **State Management:** For the real-time feel of the chat interface, you will need robust client-side state management. React hooks (`useState`, `useReducer`) may be sufficient initially, but a lightweight library like Zustand could be beneficial as complexity grows.
*   **Implement Reminders:** To implement reminders, you will need a background job runner or a cron service (like Vercel Cron Jobs) that can periodically check for upcoming events and trigger notifications (e.g., via email or web push notifications).

In summary, this repository is an excellent and highly relevant starting point for your AI Virtual Assistant. It provides the architectural backbone, leaving you to focus on the most exciting parts: defining your data, building the AI-powered logic, and creating the user-facing chat and dashboard interfaces.

## CodeGuide CLI Usage Instructions

This project is managed using CodeGuide CLI. The AI agent should follow these guidelines when working on this project.

### Essential Commands

#### Project Setup & Initialization
```bash
# Login to CodeGuide (first time setup)
codeguide login

# Start a new project (generates title, outline, docs, tasks)
codeguide start "project description prompt"

# Initialize current directory with CLI documentation
codeguide init
```

#### Task Management
```bash
# List all tasks
codeguide task list

# List tasks by status
codeguide task list --status pending
codeguide task list --status in_progress
codeguide task list --status completed

# Start working on a task
codeguide task start <task_id>

# Update task with AI results
codeguide task update <task_id> "completion summary or AI results"

# Update task status
codeguide task update <task_id> --status completed
```

#### Documentation Generation
```bash
# Generate documentation for current project
codeguide generate

# Generate documentation with custom prompt
codeguide generate --prompt "specific documentation request"

# Generate documentation for current codebase
codeguide generate --current-codebase
```

#### Project Analysis
```bash
# Analyze current project structure
codeguide analyze

# Check API health
codeguide health
```

### Workflow Guidelines

1. **Before Starting Work:**
   - Run `codeguide task list` to understand current tasks
   - Identify appropriate task to work on
   - Use `codeguide task update <task_id> --status in_progress` to begin work

2. **During Development:**
   - Follow the task requirements and scope
   - Update progress using `codeguide task update <task_id>` when significant milestones are reached
   - Generate documentation for new features using `codeguide generate`

3. **Completing Work:**
   - Update task with completion summary: `codeguide task update <task_id> "completed work summary"`
   - Mark task as completed: `codeguide task update <task_id> --status completed`
   - Generate any necessary documentation

### AI Agent Best Practices

- **Task Focus**: Work on one task at a time as indicated by the task management system
- **Documentation**: Always generate documentation for new features and significant changes
- **Communication**: Provide clear, concise updates when marking task progress
- **Quality**: Follow existing code patterns and conventions in the project
- **Testing**: Ensure all changes are properly tested before marking tasks complete

### Project Configuration
This project includes:
- `codeguide.json`: Project configuration with ID and metadata
- `documentation/`: Generated project documentation
- `AGENTS.md`: AI agent guidelines

### Getting Help
Use `codeguide --help` or `codeguide <command> --help` for detailed command information.

---
*Generated by CodeGuide CLI on 2025-10-11T10:32:49.701Z*
